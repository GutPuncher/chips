#
# cond:       the instruction byte pattern (TODO: prefix bytes)
# fetch[N]:   fetch machine-cycle (optional)
# mread[N]:   memory read machine cycle
# mwrite[N]:  memory write machine cycle
# ioread[N]:  io read machine cycle
# iowrite[N]: io write machine cycle
# generic[N]: a generic machine cycle
# overlapped: overlapped fetch/execyte 'half machine cycle' (optional)
#
# The [N] is optional for fetch (def=4), mread/mwrite (def=3) and 
# ioread/iowrite (def=4).
#
# x,y,z,p,q are opcode bit patterns:
#
#   |76|543|210|
#   |xx|yyy|zzz|
#      |ppq|
#
# Also see http://www.z80.info/decoding.htm !
#

#== QUADRANT X1 ================================================================
HALT:
  cond: (x == 1) and (y == 6) and (z == 6)
  overlapped: { code: z80_halt(c) }

LD (HL),rz:
  cond: (x == 1) and (y == 6) and (z != 6)
  mwrite: { ab: hl, db: rz }

LD ry,(HL):
  cond: (x == 1) and (y != 6) and (z == 6)
  mread: { ab: hl, dst: ry }

LD rz,ry:
  cond: (x == 1) and (y != 6) and (z != 6)
  overlapped: { code: ry=rz }

#== QUADRANT X2 ================================================================
aluy (HL):
  cond: (x == 2) and (z == 6)
  mread: { ab: hl, dst: dlatch }
  overlapped: { code: aluy(dlatch) }

aluy rz:
  cond: (x == 2) and (z != 6)
  overlapped: { func: aluy(rz) }

#== QUADRANT X0 ================================================================

# assorted ops and relative jumps
NOP:
  cond: (x == 0) and (y == 0) and (z == 0)

EX AF,AF':
  cond: (x == 0) and (y == 1) and (z == 0)
  # FIXME

DJNZ d:
  cond: (x == 0) and (y == 2) and (z == 0)
  # FIXME

JR d:
  cond: (x == 0) and (y == 3) and (z == 0)
  # FIXME

JR ccy-4,d:
  cond: (x == 0) and (y >= 4) and (y <= 7) and (z == 0)
  # FIXME

# 16-bit load immediate/add
LD rp,nn:
  cond: (x == 0) and (z == 1) and (q == 0)
  # FIXME

ADD HL,rp:
  cond: (x == 0) and (z == 1) and (q == 1)
  # FIXME

# indirect loading
LD (BC),A:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 0)
  # FIXME

LD (DE),A:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 1)
  # FIXME

LD (nn),HL:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 2)
  # FIXME

LD (nn),A:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 3)
  # FIXME

LD A,(BC):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 0)
  # FIXME

LD A,(DE):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 1)
  # FIXME

LD HL,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 2)
  # FIXME

LD A,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 3)
  # FIXME

# 16-bit inc/dec
INC rp:
  cond: (x == 0) and (z == 3) and (q == 0)
  # FIXME

DEC rp:
  cond: (x == 0) and (z == 3) and (q == 1)
  # FIXME

# 8-bit inc/dec
INC ry:
  cond: (x == 0) and (z == 4)
  # FIXME

DEC ry:
  cond: (x == 0) and (z == 5)
  # FIXME

# 8-bit load immediate
LD ry,n:
  cond: (x == 0) and (z == 6)
  # FIXME

# assorted operations on accumulator and flags
RLCA:
  cond: (x == 0) and (y == 0) and (z == 7)
  # FIXME

RRCA:
  cond: (x == 0) and (y == 1) and (z == 7)
  # FIXME

RLA:
  cond: (x == 0) and (y == 2) and (z == 7)
  # FIXME

RRA:
  cond: (x == 0) and (y == 3) and (z == 7)
  # FIXME

DAA:
  cond: (x == 0) and (y == 4) and (z == 7)
  # FIXME

CPL:
  cond: (x == 0) and (y == 5) and (z == 7)
  # FIXME

SCF:
  cond: (x == 0) and (y == 6) and (z == 7)
  # FIXME

CCF:
  cond: (x == 0) and (y == 7) and (z == 7)
  # FIXME

#== QUADRANT X3 ================================================================

# conditional return
RET ccy:
  cond: (x == 3) and (z == 0)
  # FIXME

# POP and various ops
POP rp2:
  cond: (x == 3) and (z == 1) and (q == 0)
  # FIXME

RET:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 0)
  # FIXME

EXX:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 1)
  # FIXME

JP HL:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 2)
  # FIXME

LD SP,HL:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 3)
  # FIXME

# conditional jump
JP ccy,nn:
  cond: (x == 3) and (z == 2)
  # FIXME

# assorted operations
JP nn:
  cond: (x == 3) and (y == 0) and (z == 3)
  # FIXME

CB prefix:
  cond: (x == 3) and (y == 1) and (z == 3)
  # FIXME

OUT (n),A:
  cond: (x == 3) and (y == 2) and (z == 3)
  # FIXME

IN A,(n):
  cond: (x == 3) and (y == 3) and (z == 3)
  # FIXME

EX (SP),HL:
  cond: (x == 3) and (y == 4) and (z == 3)
  # FIXME

EX DE,HL:
  cond: (x == 3) and (y == 5) and (z == 3)
  # FIXME

DI:
  cond: (x == 3) and (y == 6) and (z == 3)
  # FIXME

EI:
  cond: (x == 3) and (y == 7) and (z == 3)
  # FIXME

# conditional CALL
CALL ccy,nn:
  cond: (x == 3) and (z == 4)
  # FIXME

# PUSH and various ops
PUSH rp2:
  cond: (x == 3) and (z == 5) and (q == 0)
  # FIXME

CALL nn:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 0)
  # FIXME

DD prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 1)
  # FIXME

ED prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 2)
  # FIXME

FD prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 3)
  # FIXME

aluy n:
  cond: (x == 3) and (z == 6)
  # FIXME

RST y*8:
  cond: (x == 3) and (z == 7)
  # FIXME