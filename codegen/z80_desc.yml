# FIXME: describe syntax

#== QUADRANT X1 ================================================================
halt:
  cond: (x == 1) and (y == 6) and (z == 6)
  mcycles:
    - { type: overlapped, action: "pins=z80_halt(cpu,pins)" }

# NOTE: RRZ and RRY are special case for H and L which are never mapped
# to IXH/IYH and IXL/IYL
ld (hl),RZ:
  cond: (x == 1) and (y == 6) and (z != 6)
  flags: { indirect: true }
  mcycles:
    - { type: mwrite, ab: ADDR, db: RRZ }

ld RY,(hl):
  cond: (x == 1) and (y != 6) and (z == 6)
  flags: { indirect: true }
  mcycles:
    - { type: mread,  ab: ADDR, dst: RRY }

ld RY,RZ:
  cond: (x == 1) and (y != 6) and (z != 6)
  mcycles:
    - { type: overlapped,  action: RY=RZ }

#== QUADRANT X2 ================================================================
ALU (hl):
  cond: (x == 2) and (z == 6)
  flags: { indirect: true }
  mcycles:
    - { type: mread, ab: ADDR, dst: DLATCH }
    - { type: overlapped, action: "ALU(DLATCH)" }

ALU RZ:
  cond: (x == 2) and (z != 6)
  mcycles:
    - { type: overlapped,  action: "ALU(RZ)" }

#== QUADRANT X0 ================================================================

# assorted ops and relative jumps
nop:
  cond: (x == 0) and (y == 0) and (z == 0)
  mcycles: []

ex af,af':
  cond: (x == 0) and (y == 1) and (z == 0)
  mcycles:
    - { type: overlapped, action: "z80_ex_af_af2(cpu)" }

djnz d:
  cond: (x == 0) and (y == 2) and (z == 0)
  mcycles:
    # fetch has one extra tcycle
    - { type: fetch, tcycles: 5 }
    - { type: mread, ab: PC++, dst: DLATCH, action: "if(--B==0){z80_skip(cpu,1,7,2);}"}
    - { type: generic, tcycles: 5, action: "PC+=(int8_t)DLATCH;WZ=PC;" }

jr d:
  cond: (x == 0) and (y == 3) and (z == 0)
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: generic, tcycles: 5, action: "PC+=(int8_t)DLATCH;WZ=PC;" }

jr CC-4,d:
  cond: (x == 0) and (y >= 4) and (y <= 7) and (z == 0)
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH, action: "if(!(CC-4)){z80_skip(cpu,1,7,2);}" }
    - { type: generic, tcycles: 5, action: "PC+=(int8_t)DLATCH;WZ=PC;" }

  # FIXME

# 16-bit load immediate/add
ld RP,nn:
  cond: (x == 0) and (z == 1) and (q == 0)
  mcycles:
    - { type: mread,  ab: PC++, dst: RPL }
    - { type: mread,  ab: PC++, dst: RPH }

add hl,RP:
  cond: (x == 0) and (z == 1) and (q == 1)
  mcycles:
    - { type: generic, tcycles: 7, action: "z80_add16(cpu,RP)"}

# indirect loading
ld (bc),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 0)
  mcycles:
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: BC, db: A, action: "WZL=C+1;WZH=A" }

ld (de),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 1)
  mcycles:
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: DE, db: A, action: "WZL=E+1;WZH=A" }

ld (nn),hl:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 2)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mwrite, ab: WZ++, db: L }
    - { type: mwrite, ab: WZ, db: H }

ld (nn),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: WZ++, db: A, action: "WZH=A" }

  # FIXME

ld a,(bc):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 0)
  mcycles:
    - { type: mread, ab: BC, dst: A, action: WZ=BC+1 }

ld a,(de):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 1)
  mcycles:
    - { type: mread, ab: DE, dst: A, action: WZ=DE+1 }

ld hl,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 2)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mread, ab: WZ++, dst: L }
    - { type: mread, ab: WZ, dst: H }

ld a,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mread, ab: WZ++, dst: A }

# 16-bit inc/dec
inc RP:
  cond: (x == 0) and (z == 3) and (q == 0)
  mcycles:
    - { type: generic, tcycles: 2, action: "RP++" }

dec RP:
  cond: (x == 0) and (z == 3) and (q == 1)
  mcycles:
    - { type: generic, tcycles: 2, action: "RP--" }

# 8-bit inc/dec
inc (hl):
  cond: (x == 0) and (y == 6) and (z == 4)
  flags: { indirect: true }
  mcycles:
    - { type: mread, tcycles: 4, ab: ADDR, dst: DLATCH, action: "DLATCH=z80_inc8(cpu,DLATCH)" }
    - { type: mwrite, ab: ADDR, db: DLATCH }

inc RY:
  cond: (x == 0) and (y != 6) and (z == 4)
  mcycles:
    - { type: overlapped, action: "RY=z80_inc8(cpu,RY)" }

dec (hl):
  cond: (x == 0) and (y == 6) and (z == 5)
  flags: { indirect: true }
  mcycles:
    - { type: mread, tcycles: 4, ab: ADDR, dst: DLATCH, action: "DLATCH=z80_dec8(cpu,DLATCH)" }
    - { type: mwrite, ab: ADDR, db: DLATCH }

dec RY:
  cond: (x == 0) and (y != 6) and (z == 5)
  mcycles:
    - { type: overlapped, action: "RY=z80_dec8(cpu,RY)" }

# 8-bit load immediate
ld RY,n:
  cond: (x == 0) and (y != 6) and (z == 6)
  flags: { imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: RY }

ld (hl),n:
  cond: (x == 0) and (y == 6) and (z == 6)
  flags: { indirect: true, imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: mwrite, ab: ADDR, db: DLATCH }

# assorted operations on accumulator and flags
rlca:
  cond: (x == 0) and (y == 0) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rlca(cpu)" }

rrca:
  cond: (x == 0) and (y == 1) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rrca(cpu)" }

rla:
  cond: (x == 0) and (y == 2) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rla(cpu)" }

rra:
  cond: (x == 0) and (y == 3) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rra(cpu)" }

daa:
  cond: (x == 0) and (y == 4) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_daa(cpu)" }

cpl:
  cond: (x == 0) and (y == 5) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_cpl(cpu)" }

scf:
  cond: (x == 0) and (y == 6) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_scf(cpu)" }

ccf:
  cond: (x == 0) and (y == 7) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_ccf(cpu)" }

#== QUADRANT X3 ================================================================

# conditional return
ret CC:
  cond: (x == 3) and (z == 0)
  mcycles:
    - { type: generic, tcycles: 1, action: "if(!CC){z80_skip(cpu,4,7,1);}"}
    - { type: mread, ab: SP++, dst: WZL }
    - { type: mread, ab: SP++, dst: WZH, action: "PC=WZ" }

# POP and various ops
pop RP2:
  cond: (x == 3) and (z == 1) and (q == 0)
  mcycles:
    - { type: mread, ab: SP++, dst: RP2L }
    - { type: mread, ab: SP++, dst: RP2H }

ret:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 0)
  mcycles:
    - { type: mread, ab: SP++, dst: WZL }
    - { type: mread, ab: SP++, dst: WZH, action: "PC=WZ" }

exx:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 1)
  mcycles:
    - { type: overlapped, action: "z80_exx(cpu)" }

jp hl:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 2)
  mcycles:
    - { type: overlapped, action: "PC=HL" }

ld sp,hl:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 3)
  mcycles:
    - { type: generic, tcycles: 2, action: SP=HL }

# conditional jump
jp CC,nn:
  cond: (x == 3) and (z == 2)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH, action: "if(CC){PC=WZ;}"}

# assorted operations
jp nn:
  cond: (x == 3) and (y == 0) and (z == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH, action: "PC=WZ" }

cb prefix:
  cond: (x == 3) and (y == 1) and (z == 3)
  mcycles:
    - { type: overlapped, prefix: cb }

out (n),a:
  cond: (x == 3) and (y == 2) and (z == 3)
  mcycles:
    # NOTE: WZL++ is not a bug!
    - { type: mread, ab: PC++, dst: WZL, action: WZH=A }
    - { type: iowrite, ab: WZ, db: A, action: WZL++ }

in a,(n):
  cond: (x == 3) and (y == 3) and (z == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL, action: WZH=A }
    - { type: ioread, ab: WZ++, dst: DLATCH }
    - { type: overlapped, action: A=DLATCH }

ex (sp),hl:
  cond: (x == 3) and (y == 4) and (z == 3)
  mcycles:
    - { type: mread, ab: SP, dst: WZL }
    - { type: mread, tcycles: 4, ab: SP+1, dst: WZH }
    - { type: mwrite, ab: SP+1, db: H }
    - { type: mwrite, tcycles: 5, ab: SP, db: L, action: HL=WZ }

ex de,hl:
  cond: (x == 3) and (y == 5) and (z == 3)
  mcycles:
    - { type: overlapped, action: "z80_ex_de_hl(cpu)" }

di:
  cond: (x == 3) and (y == 6) and (z == 3)
  mcycles: []
  # FIXME

ei:
  cond: (x == 3) and (y == 7) and (z == 3)
  mcycles: []
  # FIXME

# conditional CALL
call CC,nn:
  cond: (x == 3) and (z == 4)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH, action: "if (!CC){z80_skip(cpu,5,9,2);}" }
    - { type: generic, tcycles: 1 }
    - { type: mwrite, ab: --SP, db: PCH }
    - { type: mwrite, ab: --SP, db: PCL, action: "PC=WZ" }

# PUSH and various ops
push RP2:
  cond: (x == 3) and (z == 5) and (q == 0)
  mcycles:
    # fetch has one extra tcycle
    - { type: fetch, tcycles: 5 }
    - { type: mwrite, ab: --SP, db: RP2H }
    - { type: mwrite, ab: --SP, db: RP2L }

call nn:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 0)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, tcycles: 4, ab: PC++, dst: WZH }
    - { type: mwrite, ab: --SP, db: PCH }
    - { type: mwrite, ab: --SP, db: PCL, action: "PC=WZ" }

dd prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 1)
  mcycles:
    - { type: overlapped, prefix: dd }

ed prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 2)
  mcycles:
    - { type: overlapped, prefix: ed }

fd prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 3)
  mcycles:
    - { type: overlapped, prefix: fd }

ALU n:
  cond: (x == 3) and (z == 6)
  flags: { imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: overlapped, action: "ALU(DLATCH)" }

rst Y*8:
  cond: (x == 3) and (z == 7)
  mcycles:
    # one extra tcycle
    - { type: fetch, tcycles: 5 }
    - { type: mwrite, ab: --SP, db: PCH }
    - { type: mwrite, ab: --SP, db: PCL, action: "WZ=Y*8;PC=WZ"}

#== ED prefix block ============================================================
ed nop:
  prefix: ed
  flags: { single: true }
  cond: (x == 0) or (x == 3) or ((x == 1) and (z == 7) and (y >= 6)) or ((x == 2) and ((z > 3) or (y < 4)))
  mcycles: []

in RY,(c):
  prefix: ed
  cond: (x == 1) and (y != 6) and (z == 0)
  mcycles:
    - { type: ioread, ab: BC, dst: DLATCH, action: WZ=BC+1 }
    - { type: overlapped, action: "RY=z80_in(cpu,DLATCH)" }

in (c):
  prefix: ed
  cond: (x == 1) and (y == 6) and (z == 0)
  mcycles:
    - { type: ioread, ab: BC, dst: DLATCH, action: WZ=BC+1 }
    # discard result, only set flags
    - { type: overlapped, action: "z80_in(cpu,DLATCH)" }

out (c),RY:
  prefix: ed
  cond: (x == 1) and (y != 6) and (z == 1)
  mcycles:
    - { type: iowrite, ab: BC, db: RY, action: WZ=BC+1 }

out (c),0:
  prefix: ed
  cond: (x == 1) and (y == 6) and (z == 1)
  mcycles:
    - { type: iowrite, ab: BC, db: "0", action: WZ=BC+1 }

sbc hl,RP:
  prefix: ed
  cond: (x == 1) and (z == 2) and (q == 0)
  mcycles:
    - { type: generic, tcycles: 7, action: "z80_sbc16(cpu,RRP)" }

adc hl,RP:
  prefix: ed
  cond: (x == 1) and (z == 2) and (q == 1)
  mcycles:
    - { type: generic, tcycles: 7, action: "z80_adc16(cpu,RRP)" }

ld (nn),RP:
  prefix: ed
  cond: (x == 1) and (z == 3) and (q == 0)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mwrite, ab: WZ++, db: RRPL }
    - { type: mwrite, ab: WZ, db: RRPH }
  
ld RP,(nn):
  prefix: ed
  cond: (x == 1) and (z == 3) and (q == 1)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mread, ab: WZ++, dst: RRPL }
    - { type: mread, ab: WZ, dst: RRPH }

neg:
  prefix: ed
  cond: (x == 1) and (z == 4)
  flags: { single: true }
  mcycles:
    - { type: overlapped, action: "z80_neg8(cpu)"}

retn:
  prefix: ed
  cond: (x == 1) and (y != 1) and (z == 5)
  flags: { single: true }
  mcycles: []
  # FIXME

reti:
  prefix: ed
  cond: (x == 1) and (y == 1) and (z == 5)
  mcycles: []
  # FIXME

im IMY:
  prefix: ed
  cond: (x == 1) and (z == 6)
  mcycles: []
  # FIXME

ld i,a:
  prefix: ed
  cond: (x == 1) and (y == 0) and (z == 7)
  mcycles: []
  # FIXME

ld r,a:
  prefix: ed
  cond: (x == 1) and (y == 1) and (z == 7)
  mcycles: []
  # FIXME

ld a,i:
  prefix: ed
  cond: (x == 1) and (y == 2) and (z == 7)
  mcycles: []
  # FIXME

ld a,r:
  prefix: ed
  cond: (x == 1) and (y == 3) and (z == 7)
  mcycles: []
  # FIXME

rrd:
  prefix: ed
  cond: (x == 1) and (y == 4) and (z == 7)
  mcycles: []
  # FIXME

rld:
  prefix: ed
  cond: (x == 1) and (y == 5) and (z == 7)
  mcycles: []
  # FIXME

ldi:
  prefix: ed
  cond: (x == 2) and (y == 4) and (z == 0)
  mcycles:
    - { type: mread, ab: "cpu->hl++", dst: DLATCH }
    - { type: mwrite, ab: "cpu->de++", db: DLATCH }
    - { type: generic, tcycles: 2, action: "z80_ldi_ldd(cpu,DLATCH)" }

ldd:
  prefix: ed
  cond: (x == 2) and (y == 5) and (z == 0)
  mcycles:
    - { type: mread, ab: "cpu->hl--", dst: DLATCH }
    - { type: mwrite, ab: "cpu->de--", db: DLATCH }
    - { type: generic, tcycles: 2, action: "z80_ldi_ldd(cpu,DLATCH)" }

ldir:
  prefix: ed
  cond: (x == 2) and (y == 6) and (z == 0)
  mcycles:
    - { type: mread, ab: "cpu->hl++", dst: DLATCH }
    - { type: mwrite, ab: "cpu->de++", db: DLATCH }
    - { type: generic, tcycles: 2, action: "if(!z80_ldi_ldd(cpu,DLATCH)){z80_skip(cpu,1,7,2);}"}
    - { type: generic, tcycles: 5, action: "WZ=--PC;--PC;" }

lddr:
  prefix: ed
  cond: (x == 2) and (y == 7) and (z == 0)
  mcycles:
    - { type: mread, ab: "cpu->hl--", dst: DLATCH }
    - { type: mwrite, ab: "cpu->de--", db: DLATCH }
    - { type: generic, tcycles: 2, action: "if(!z80_ldi_ldd(cpu,DLATCH)){z80_skip(cpu,1,7,2);}"}
    - { type: generic, tcycles: 5, action: "WZ=--PC;--PC;" }

cpi:
  prefix: ed
  cond: (x == 2) and (y == 4) and (z == 1)
  mcycles:
    - { type: mread, ab: "cpu->hl++", dst: DLATCH }
    - { type: generic, tcycles: 5, action: "WZ++;z80_cpi_cpd(cpu,DLATCH)"}

cpd:
  prefix: ed
  cond: (x == 2) and (y == 5) and (z == 1)
  mcycles:
    - { type: mread, ab: "cpu->hl--", dst: DLATCH }
    - { type: generic, tcycles: 5, action: "WZ--;z80_cpi_cpd(cpu,DLATCH)"}

cpir:
  prefix: ed
  cond: (x == 2) and (y == 6) and (z == 1)
  mcycles:
    - { type: mread, ab: "cpu->hl++", dst: DLATCH }
    - { type: generic, tcycles: 5, action: "WZ++;if(!z80_cpi_cpd(cpu,DLATCH)){z80_skip(cpu,1,7,2);}"}
    - { type: generic, tcycles: 5, action: "WZ=--PC;--PC"}

cpdr:
  prefix: ed
  cond: (x == 2) and (y == 7) and (z == 1)
  mcycles:
    - { type: mread, ab: "cpu->hl--", dst: DLATCH }
    - { type: generic, tcycles: 5, action: "WZ--;if(!z80_cpi_cpd(cpu,DLATCH)){z80_skip(cpu,1,7,2);}"}
    - { type: generic, tcycles: 5, action: "WZ=--PC;--PC"}

ini:
  prefix: ed
  cond: (x == 2) and (y == 4) and (z == 2)
  mcycles: 
    - { type: fetch, tcycles: 5 }
    - { type: ioread, ab: BC, dst: DLATCH, action: "WZ=BC+1;B--;" }
    - { type: mwrite, ab: "cpu->hl++", db: DLATCH, action: "z80_ini_ind(cpu,DLATCH,C+1)" }

ind:
  prefix: ed
  cond: (x == 2) and (y == 5) and (z == 2)
  mcycles:
    - { type: fetch, tcycles: 5 }
    - { type: ioread, ab: BC, dst: DLATCH, action: "WZ=BC-1;B--;" }
    - { type: mwrite, ab: "cpu->hl--", db: DLATCH, action: "z80_ini_ind(cpu,DLATCH,C-1)" }

inir:
  prefix: ed
  cond: (x == 2) and (y == 6) and (z == 2)
  mcycles: []

indr:
  prefix: ed
  cond: (x == 2) and (y == 7) and (z == 2)
  mcycles: []
  # FIXME

outi:
  prefix: ed
  cond: (x == 2) and (y == 4) and (z == 3)
  mcycles: []
  # FIXME

outd:
  prefix: ed
  cond: (x == 2) and (y == 5) and (z == 3)
  mcycles: []
  # FIXME

otir:
  prefix: ed
  cond: (x == 2) and (y == 6) and (z == 3)
  mcycles: []
  # FIXME

otdr:
  prefix: ed
  cond: (x == 2) and (y == 7) and (z == 3)
  mcycles: []
  # FIXME

#== CB prefix block ============================================================

ROT (hl):
  prefix: cb
  cond: (x == 0) and (z == 6)
  mcycles: []
  # FIXME

ROT RZ:
  prefix: cb
  cond: (x == 0) and (z != 6)
  mcycles: []
  # FIXME

bit n,(hl):
  prefix: cb
  flags: { single: true }
  cond: (x == 1) and (z == 6)
  mcycles: []
  # FIXME

bit n,r:
  prefix: cb
  flags: { single: true }
  cond: (x == 1) and (z != 6)
  mcycles: []
  # FIXME

res n,(hl):
  prefix: cb
  flags: { single: true }
  cond: (x == 2) and (z == 6)
  mcycles: []
  # FIXME

res n,r:
  prefix: cb
  flags: { single: true }
  cond: (x == 2) and (z != 6)
  mcycles: []
  # FIXME

set n,(hl):
  prefix: cb
  flags: { single: true }
  cond: (x == 3) and (z == 6)
  mcycles: []

set n,r:
  prefix: cb
  flags: { single: true }
  cond: (x == 3) and (z != 6)
  mcycles: []
