# FIXME: describe syntax

#== QUADRANT X1 ================================================================
halt:
  cond: (x == 1) and (y == 6) and (z == 6)
  mcycles:
    - { type: overlapped, action: "z80_halt(cpu)" }

# NOTE: RRZ and RRY are special case for H and L which are never mapped
# to IXH/IYH and IXL/IYL
ld (hl),RZ:
  cond: (x == 1) and (y == 6) and (z != 6)
  flags: { indirect: true }
  mcycles:
    - { type: mwrite, ab: ADDR, db: RRZ }

ld RY,(hl):
  cond: (x == 1) and (y != 6) and (z == 6)
  flags: { indirect: true }
  mcycles:
    - { type: mread,  ab: ADDR, dst: RRY }

ld RY,RZ:
  cond: (x == 1) and (y != 6) and (z != 6)
  mcycles:
    - { type: overlapped,  action: RY=RZ }

#== QUADRANT X2 ================================================================
ALU (hl):
  cond: (x == 2) and (z == 6)
  flags: { indirect: true }
  mcycles:
    - { type: mread, ab: ADDR, dst: DLATCH }
    - { type: overlapped, action: "ALU(DLATCH)" }

ALU RZ:
  cond: (x == 2) and (z != 6)
  mcycles:
    - { type: overlapped,  action: "ALU(RZ)" }

#== QUADRANT X0 ================================================================

# assorted ops and relative jumps
nop:
  cond: (x == 0) and (y == 0) and (z == 0)
  mcycles: []

ex af,af':
  cond: (x == 0) and (y == 1) and (z == 0)
  mcycles: []
  # FIXME

djnz d:
  cond: (x == 0) and (y == 2) and (z == 0)
  mcycles: []
  # FIXME

jr d:
  cond: (x == 0) and (y == 3) and (z == 0)
  mcycles: []
  # FIXME

jr CC-4,d:
  cond: (x == 0) and (y >= 4) and (y <= 7) and (z == 0)
  mcycles: []
  # FIXME

# 16-bit load immediate/add
ld RP,nn:
  cond: (x == 0) and (z == 1) and (q == 0)
  mcycles:
    - { type: mread,  ab: PC++, dst: RPL }
    - { type: mread,  ab: PC++, dst: RPH }

add hl,RP:
  cond: (x == 0) and (z == 1) and (q == 1)
  mcycles: []
  # FIXME

# indirect loading
ld (bc),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 0)
  mcycles:
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: BC, db: A, action: "WZL=C+1;WZH=A" }

ld (de),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 1)
  mcycles:
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: DE, db: A, action: "WZL=E+1;WZH=A" }

ld (nn),hl:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 2)
  mcycles: []
  # FIXME

ld (nn),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: WZ++, db: A, action: "WZH=A" }

  # FIXME

ld a,(bc):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 0)
  mcycles:
    - { type: mread, ab: BC, dst: A, action: WZ=BC+1 }

ld a,(de):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 1)
  mcycles:
    - { type: mread, ab: DE, dst: A, action: WZ=DE+1 }

ld hl,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 2)
  mcycles: []

ld a,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mread, ab: WZ++, dst: A }

# 16-bit inc/dec
inc RP:
  cond: (x == 0) and (z == 3) and (q == 0)
  mcycles: []
  # FIXME

dec RP:
  cond: (x == 0) and (z == 3) and (q == 1)
  mcycles: []
  # FIXME

# 8-bit inc/dec
inc RY:
  cond: (x == 0) and (z == 4)
  mcycles: []
  # FIXME

dec RY:
  cond: (x == 0) and (z == 5)
  mcycles: []
  # FIXME

# 8-bit load immediate
ld RY,n:
  cond: (x == 0) and (y != 6) and (z == 6)
  flags: { imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: RY }

ld (hl),n:
  cond: (x == 0) and (y == 6) and (z == 6)
  flags: { indirect: true, imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: mwrite, ab: ADDR, db: DLATCH }

# assorted operations on accumulator and flags
rlca:
  cond: (x == 0) and (y == 0) and (z == 7)
  mcycles: []
  # FIXME

rrca:
  cond: (x == 0) and (y == 1) and (z == 7)
  mcycles: []
  # FIXME

rla:
  cond: (x == 0) and (y == 2) and (z == 7)
  mcycles: []
  # FIXME

rra:
  cond: (x == 0) and (y == 3) and (z == 7)
  mcycles: []
  # FIXME

daa:
  cond: (x == 0) and (y == 4) and (z == 7)
  mcycles: []
  # FIXME

cpl:
  cond: (x == 0) and (y == 5) and (z == 7)
  mcycles: []
  # FIXME

scf:
  cond: (x == 0) and (y == 6) and (z == 7)
  mcycles: []
  # FIXME

ccf:
  cond: (x == 0) and (y == 7) and (z == 7)
  mcycles: []
  # FIXME

#== QUADRANT X3 ================================================================

# conditional return
ret CC:
  cond: (x == 3) and (z == 0)
  mcycles: []
  # FIXME

# POP and various ops
pop RP2:
  cond: (x == 3) and (z == 1) and (q == 0)
  mcycles: []
  # FIXME

ret:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 0)
  mcycles: []
  # FIXME

exx:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 1)
  mcycles: []
  # FIXME

jp hl:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 2)
  mcycles: []
  # FIXME

ld sp,hl:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 3)
  mcycles: []
  # FIXME

# conditional jump
jp CC,nn:
  cond: (x == 3) and (z == 2)
  mcycles: []
  # FIXME

# assorted operations
jp nn:
  cond: (x == 3) and (y == 0) and (z == 3)
  mcycles: []
  # FIXME

cb prefix:
  cond: (x == 3) and (y == 1) and (z == 3)
  mcycles: []
  # FIXME

out (n),a:
  cond: (x == 3) and (y == 2) and (z == 3)
  mcycles: []
  # FIXME

in a,(n):
  cond: (x == 3) and (y == 3) and (z == 3)
  mcycles: []
  # FIXME

ex (sp),hl:
  cond: (x == 3) and (y == 4) and (z == 3)
  mcycles: []
  # FIXME

ex de,hl:
  cond: (x == 3) and (y == 5) and (z == 3)
  mcycles: []
  # FIXME

di:
  cond: (x == 3) and (y == 6) and (z == 3)
  mcycles: []
  # FIXME

ei:
  cond: (x == 3) and (y == 7) and (z == 3)
  mcycles: []
  # FIXME

# conditional CALL
call CC,nn:
  cond: (x == 3) and (z == 4)
  mcycles: []
  # FIXME

# PUSH and various ops
push RP2:
  cond: (x == 3) and (z == 5) and (q == 0)
  mcycles: []
  # FIXME

call nn:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 0)
  mcycles: []
  # FIXME

dd prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 1)
  mcycles:
    - { type: overlapped, prefix: ix }

ed prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 2)
  mcycles: []
  # FIXME

fd prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 3)
  mcycles:
    - { type: overlapped, prefix: iy }

ALU n:
  cond: (x == 3) and (z == 6)
  flags: { imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: overlapped, action: "ALU(DLATCH)" }

rst Y*8:
  cond: (x == 3) and (z == 7)
  mcycles: []
  # FIXME