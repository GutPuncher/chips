# FIXME: describe syntax

#== QUADRANT X1 ================================================================
halt:
  cond: (x == 1) and (y == 6) and (z == 6)
  mcycles:
    - { type: overlapped, action: "pins=z80_halt(cpu,pins)" }

# NOTE: RRZ and RRY are special case for H and L which are never mapped
# to IXH/IYH and IXL/IYL
ld (hl),RZ:
  cond: (x == 1) and (y == 6) and (z != 6)
  flags: { indirect: true }
  mcycles:
    - { type: mwrite, ab: ADDR, db: RRZ }

ld RY,(hl):
  cond: (x == 1) and (y != 6) and (z == 6)
  flags: { indirect: true }
  mcycles:
    - { type: mread,  ab: ADDR, dst: RRY }

ld RY,RZ:
  cond: (x == 1) and (y != 6) and (z != 6)
  mcycles:
    - { type: overlapped,  action: RY=RZ }

#== QUADRANT X2 ================================================================
ALU (hl):
  cond: (x == 2) and (z == 6)
  flags: { indirect: true }
  mcycles:
    - { type: mread, ab: ADDR, dst: DLATCH }
    - { type: overlapped, action: "ALU(DLATCH)" }

ALU RZ:
  cond: (x == 2) and (z != 6)
  mcycles:
    - { type: overlapped,  action: "ALU(RZ)" }

#== QUADRANT X0 ================================================================

# assorted ops and relative jumps
nop:
  cond: (x == 0) and (y == 0) and (z == 0)
  mcycles: []

ex af,af':
  cond: (x == 0) and (y == 1) and (z == 0)
  mcycles:
    - { type: overlapped, action: "z80_ex_af_af2(cpu)" }

djnz d:
  cond: (x == 0) and (y == 2) and (z == 0)
  mcycles: []
  # FIXME

jr d:
  cond: (x == 0) and (y == 3) and (z == 0)
  mcycles: []
  # FIXME

jr CC-4,d:
  cond: (x == 0) and (y >= 4) and (y <= 7) and (z == 0)
  mcycles: []
  # FIXME

# 16-bit load immediate/add
ld RP,nn:
  cond: (x == 0) and (z == 1) and (q == 0)
  mcycles:
    - { type: mread,  ab: PC++, dst: RPL }
    - { type: mread,  ab: PC++, dst: RPH }

add hl,RP:
  cond: (x == 0) and (z == 1) and (q == 1)
  mcycles: []
  # FIXME

# indirect loading
ld (bc),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 0)
  mcycles:
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: BC, db: A, action: "WZL=C+1;WZH=A" }

ld (de),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 1)
  mcycles:
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: DE, db: A, action: "WZL=E+1;WZH=A" }

ld (nn),hl:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 2)
  mcycles: []
  # FIXME

ld (nn),a:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    # NOTE: WZH can also be 0 on Z80 clones (the VisualZ80 netlist also sets WZH to zero)
    - { type: mwrite, ab: WZ++, db: A, action: "WZH=A" }

  # FIXME

ld a,(bc):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 0)
  mcycles:
    - { type: mread, ab: BC, dst: A, action: WZ=BC+1 }

ld a,(de):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 1)
  mcycles:
    - { type: mread, ab: DE, dst: A, action: WZ=DE+1 }

ld hl,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 2)
  mcycles: []

ld a,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 3)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH }
    - { type: mread, ab: WZ++, dst: A }

# 16-bit inc/dec
inc RP:
  cond: (x == 0) and (z == 3) and (q == 0)
  mcycles:
    - { type: generic, tcycles: 2, action: "RP++" }

dec RP:
  cond: (x == 0) and (z == 3) and (q == 1)
  mcycles:
    - { type: generic, tcycles: 2, action: "RP--" }

# 8-bit inc/dec
inc (hl):
  cond: (x == 0) and (y == 6) and (z == 4)
  flags: { indirect: true }
  mcycles:
    - { type: mread, tcycles: 4, ab: ADDR, dst: DLATCH, action: "DLATCH=z80_inc8(cpu,DLATCH)" }
    - { type: mwrite, ab: ADDR, db: DLATCH }

inc RY:
  cond: (x == 0) and (y != 6) and (z == 4)
  mcycles:
    - { type: overlapped, action: "RY=z80_inc8(cpu,RY)" }

dec (hl):
  cond: (x == 0) and (y == 6) and (z == 5)
  flags: { indirect: true }
  mcycles:
    - { type: mread, tcycles: 4, ab: ADDR, dst: DLATCH, action: "DLATCH=z80_dec8(cpu,DLATCH)" }
    - { type: mwrite, ab: ADDR, db: DLATCH }

dec RY:
  cond: (x == 0) and (y != 6) and (z == 5)
  mcycles:
    - { type: overlapped, action: "RY=z80_dec8(cpu,RY)" }

# 8-bit load immediate
ld RY,n:
  cond: (x == 0) and (y != 6) and (z == 6)
  flags: { imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: RY }

ld (hl),n:
  cond: (x == 0) and (y == 6) and (z == 6)
  flags: { indirect: true, imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: mwrite, ab: ADDR, db: DLATCH }

# assorted operations on accumulator and flags
rlca:
  cond: (x == 0) and (y == 0) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rlca(cpu)" }

rrca:
  cond: (x == 0) and (y == 1) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rrca(cpu)" }

rla:
  cond: (x == 0) and (y == 2) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rla(cpu)" }

rra:
  cond: (x == 0) and (y == 3) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_rra(cpu)" }

daa:
  cond: (x == 0) and (y == 4) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_daa(cpu)" }

cpl:
  cond: (x == 0) and (y == 5) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_cpl(cpu)" }

scf:
  cond: (x == 0) and (y == 6) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_scf(cpu)" }

ccf:
  cond: (x == 0) and (y == 7) and (z == 7)
  mcycles:
    - { type: overlapped, action: "z80_ccf(cpu)" }

#== QUADRANT X3 ================================================================

# conditional return
ret CC:
  cond: (x == 3) and (z == 0)
  mcycles: []
  # FIXME

# POP and various ops
pop RP2:
  cond: (x == 3) and (z == 1) and (q == 0)
  mcycles:
    - { type: mread, ab: SP++, dst: RP2L }
    - { type: mread, ab: SP++, dst: RP2H }

ret:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 0)
  mcycles: []
  # FIXME

exx:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 1)
  mcycles:
    - { type: overlapped, action: "z80_exx(cpu)" }

jp hl:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 2)
  mcycles: []
  # FIXME

ld sp,hl:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 3)
  mcycles:
    - { type: generic, tcycles: 2, action: SP=HL }

# conditional jump
jp CC,nn:
  cond: (x == 3) and (z == 2)
  mcycles:
    - { type: mread, ab: PC++, dst: WZL }
    - { type: mread, ab: PC++, dst: WZH, action: "if(CC){PC=WZ;}"}

# assorted operations
jp nn:
  cond: (x == 3) and (y == 0) and (z == 3)
  mcycles: []
  # FIXME

cb prefix:
  cond: (x == 3) and (y == 1) and (z == 3)
  mcycles: []
  # FIXME

out (n),a:
  cond: (x == 3) and (y == 2) and (z == 3)
  mcycles: []
  # FIXME

in a,(n):
  cond: (x == 3) and (y == 3) and (z == 3)
  mcycles: []
  # FIXME

ex (sp),hl:
  cond: (x == 3) and (y == 4) and (z == 3)
  mcycles:
    - { type: mread, ab: SP, dst: WZL }
    - { type: mread, tcycles: 4, ab: SP+1, dst: WZH }
    - { type: mwrite, ab: SP+1, db: H }
    - { type: mwrite, tcycles: 5, ab: SP, db: L, action: HL=WZ }

ex de,hl:
  cond: (x == 3) and (y == 5) and (z == 3)
  mcycles:
    - { type: overlapped, action: "z80_ex_de_hl(cpu)" }

di:
  cond: (x == 3) and (y == 6) and (z == 3)
  mcycles: []
  # FIXME

ei:
  cond: (x == 3) and (y == 7) and (z == 3)
  mcycles: []
  # FIXME

# conditional CALL
call CC,nn:
  cond: (x == 3) and (z == 4)
  mcycles: []
  # FIXME

# PUSH and various ops
push RP2:
  cond: (x == 3) and (z == 5) and (q == 0)
  mcycles:
    # fetch has one extra tcycle
    - { type: fetch, tcycles: 5 }
    - { type: mwrite, ab: --SP, db: RP2H }
    - { type: mwrite, ab: --SP, db: RP2L }

call nn:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 0)
  mcycles: []
  # FIXME

dd prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 1)
  mcycles:
    - { type: overlapped, prefix: ix }

ed prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 2)
  mcycles: []
  # FIXME

fd prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 3)
  mcycles:
    - { type: overlapped, prefix: iy }

ALU n:
  cond: (x == 3) and (z == 6)
  flags: { imm8: true }
  mcycles:
    - { type: mread, ab: PC++, dst: DLATCH }
    - { type: overlapped, action: "ALU(DLATCH)" }

rst Y*8:
  cond: (x == 3) and (z == 7)
  mcycles: []
  # FIXME