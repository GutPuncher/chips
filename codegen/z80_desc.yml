#
# cond:       the instruction byte pattern (TODO: prefix bytes)
# fetch[N]:   fetch machine-cycle (optional)
# mread[N]:   memory read machine cycle
# mwrite[N]:  memory write machine cycle
# ioread[N]:  io read machine cycle
# iowrite[N]: io write machine cycle
# generic[N]: a generic machine cycle
# overlapped: overlapped fetch/execyte 'half machine cycle' (optional)
#
# The [N] is optional for fetch (def=4), mread/mwrite (def=3) and 
# ioread/iowrite (def=4).
#
# x,y,z,p,q are opcode bit patterns:
#
#   |76|543|210|
#   |xx|yyy|zzz|
#      |ppq|
#
# Also see http://www.z80.info/decoding.htm !
#

#== QUADRANT X1 ================================================================
HALT:
  cond: (x == 1) and (y == 6) and (z == 6)
  overlapped: halt

LD (HL),r[z]:
  cond: (x == 1) and (y == 6) and (z != 6)
  mwrite: addr=hl, dbus=r[z]

LD r[y],(HL):
  cond: (x == 1) and (y != 6) and (z == 6)
  mread: addr=hl, dest=dlatch
  overlapped: r[y]=dlatch

LD r[z],r[y]:
  cond: (x == 1) and (y != 6) and (z != 6)
  overlapped: r[y]=r[z]

#== QUADRANT X2 ================================================================
alu[y] (HL):
  cond: (x == 2) and (z == 6)
  mread: addr=hl, dest=dlatch
  overlapped: func=alu[y](dlatch)

alu[y] r[z]:
  cond: (x == 2) and (z != 6)
  overlapped: func=alu[y](r[z])

#== QUADRANT X0 ================================================================

# assorted ops and relative jumps
NOP:
  cond: (x == 0) and (y == 0) and (z == 0)

EX AF,AF':
  cond: (x == 0) and (y == 1) and (z == 0)
  # FIXME

DJNZ d:
  cond: (x == 0) and (y == 2) and (z == 0)
  # FIXME

JR d:
  cond: (x == 0) and (y == 3) and (z == 0)
  # FIXME

JR cc[y-4],d:
  cond: (x == 0) and (y >= 4) and (y <= 7) and (z == 0)
  # FIXME

# 16-bit load immediate/add
LD rp[p],nn:
  cond: (x == 0) and (z == 1) and (q == 0)
  # FIXME

ADD HL,rp[p]:
  cond: (x == 0) and (z == 1) and (q == 1)
  # FIXME

# indirect loading
LD (BC),A:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 0)
  # FIXME

LD (DE),A:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 1)
  # FIXME

LD (nn),HL:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 2)
  # FIXME

LD (nn),A:
  cond: (x == 0) and (z == 2) and (q == 0) and (p == 3)
  # FIXME

LD A,(BC):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 0)
  # FIXME

LD A,(DE):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 1)
  # FIXME

LD HL,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 2)
  # FIXME

LD A,(nn):
  cond: (x == 0) and (z == 2) and (q == 1) and (p == 3)
  # FIXME

# 16-bit inc/dec
INC rp[p]:
  cond: (x == 0) and (z == 3) and (q == 0)
  # FIXME

DEC rp[p]:
  cond: (x == 0) and (z == 3) and (q == 1)
  # FIXME

# 8-bit inc/dec
INC r[y]:
  cond: (x == 0) and (z == 4)
  # FIXME

DEC r[y]:
  cond: (x == 0) and (z == 5)
  # FIXME

# 8-bit load immediate
LD r[y],n:
  cond: (x == 0) and (z == 6)
  # FIXME

# assorted operations on accumulator and flags
RLCA:
  cond: (x == 0) and (y == 0) and (z == 7)
  # FIXME

RRCA:
  cond: (x == 0) and (y == 1) and (z == 7)
  # FIXME

RLA:
  cond: (x == 0) and (y == 2) and (z == 7)
  # FIXME

RRA:
  cond: (x == 0) and (y == 3) and (z == 7)
  # FIXME

DAA:
  cond: (x == 0) and (y == 4) and (z == 7)
  # FIXME

CPL:
  cond: (x == 0) and (y == 5) and (z == 7)
  # FIXME

SCF:
  cond: (x == 0) and (y == 6) and (z == 7)
  # FIXME

CCF:
  cond: (x == 0) and (y == 7) and (z == 7)
  # FIXME

#== QUADRANT X3 ================================================================

# conditional return
RET cc[y]:
  cond: (x == 3) and (z == 0)
  # FIXME

# POP and various ops
POP rp2[p]:
  cond: (x == 3) and (z == 1) and (q == 0)
  # FIXME

RET:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 0)
  # FIXME

EXX:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 1)
  # FIXME

JP HL:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 2)
  # FIXME

LD SP,HL:
  cond: (x == 3) and (z == 1) and (q == 1) and (p == 3)
  # FIXME

# conditional jump
JP cc[y],nn:
  cond: (x == 3) and (z == 2)
  # FIXME

# assorted operations
JP nn:
  cond: (x == 3) and (y == 0) and (z == 3)
  # FIXME

CB prefix:
  cond: (x == 3) and (y == 1) and (z == 3)
  # FIXME

OUT (n),A:
  cond: (x == 3) and (y == 2) and (z == 3)
  # FIXME

IN A,(n):
  cond: (x == 3) and (y == 3) and (z == 3)
  # FIXME

EX (SP),HL:
  cond: (x == 3) and (y == 4) and (z == 3)
  # FIXME

EX DE,HL:
  cond: (x == 3) and (y == 5) and (z == 3)
  # FIXME

DI:
  cond: (x == 3) and (y == 6) and (z == 3)
  # FIXME

EI:
  cond: (x == 3) and (y == 7) and (z == 3)
  # FIXME

# conditional CALL
CALL cc[y],nn:
  cond: (x == 3) and (z == 4)
  # FIXME

# PUSH and various ops
PUSH rp2[p]:
  cond: (x == 3) and (z == 5) and (q == 0)
  # FIXME

CALL nn:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 0)
  # FIXME

DD prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 1)
  # FIXME

ED prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 2)
  # FIXME

FD prefix:
  cond: (x == 3) and (z == 5) and (q == 1) and (p == 3)
  # FIXME

alu[y] n:
  cond: (x == 3) and (z == 6)
  # FIXME

RST y*8:
  cond: (x == 3) and (z == 7)
  # FIXME